/* automatically generated by rust-bindgen 0.71.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const R_ACCESS: u32 = 0;
pub const W_ACCESS: u32 = 1;
pub const RW_ACCESS: u32 = 2;
pub const RWE_ACCESS: u32 = 3;
pub type va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " \\struct  bankSector.\n \\brief   This stucture indicates the sectors parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bankSector {
    #[doc = "< Index of the sector."]
    pub index: ::std::os::raw::c_uint,
    #[doc = "< Sector size."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< Sector starting address."]
    pub address: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bankSector"][::std::mem::size_of::<bankSector>() - 12usize];
    ["Alignment of bankSector"][::std::mem::align_of::<bankSector>() - 4usize];
    ["Offset of field: bankSector::index"][::std::mem::offset_of!(bankSector, index) - 0usize];
    ["Offset of field: bankSector::size"][::std::mem::offset_of!(bankSector, size) - 4usize];
    ["Offset of field: bankSector::address"][::std::mem::offset_of!(bankSector, address) - 8usize];
};
#[doc = " \\struct  deviceBank.\n \\brief   This stucture defines the memory sectors for each bank."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct deviceBank {
    #[doc = "< Number of sectors of the considered bank."]
    pub sectorsNumber: ::std::os::raw::c_uint,
    #[doc = "< Sectors specifications #Bank_Sector."]
    pub sectors: *mut bankSector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of deviceBank"][::std::mem::size_of::<deviceBank>() - 16usize];
    ["Alignment of deviceBank"][::std::mem::align_of::<deviceBank>() - 8usize];
    ["Offset of field: deviceBank::sectorsNumber"]
        [::std::mem::offset_of!(deviceBank, sectorsNumber) - 0usize];
    ["Offset of field: deviceBank::sectors"][::std::mem::offset_of!(deviceBank, sectors) - 8usize];
};
#[doc = " \\struct  storageStructure.\n \\brief   This stucture describes sotrage characterization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storageStructure {
    #[doc = "< Number of exsisted banks."]
    pub banksNumber: ::std::os::raw::c_uint,
    #[doc = "< Banks sectors definition #Device_Bank."]
    pub banks: *mut deviceBank,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of storageStructure"][::std::mem::size_of::<storageStructure>() - 16usize];
    ["Alignment of storageStructure"][::std::mem::align_of::<storageStructure>() - 8usize];
    ["Offset of field: storageStructure::banksNumber"]
        [::std::mem::offset_of!(storageStructure, banksNumber) - 0usize];
    ["Offset of field: storageStructure::banks"]
        [::std::mem::offset_of!(storageStructure, banks) - 8usize];
};
#[doc = " \\struct  bitCoefficient_C.\n \\brief   This stucture indicates the coefficients to access to the adequate option bit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitCoefficient_C {
    #[doc = "< Bit multiplier."]
    pub multiplier: ::std::os::raw::c_uint,
    #[doc = "< Bit offset."]
    pub offset: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bitCoefficient_C"][::std::mem::size_of::<bitCoefficient_C>() - 8usize];
    ["Alignment of bitCoefficient_C"][::std::mem::align_of::<bitCoefficient_C>() - 4usize];
    ["Offset of field: bitCoefficient_C::multiplier"]
        [::std::mem::offset_of!(bitCoefficient_C, multiplier) - 0usize];
    ["Offset of field: bitCoefficient_C::offset"]
        [::std::mem::offset_of!(bitCoefficient_C, offset) - 4usize];
};
#[doc = " \\struct  bitValue_C.\n \\brief   This stucture describes the option Bit value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitValue_C {
    #[doc = "< Option bit value."]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Option bit description."]
    pub description: [::std::os::raw::c_char; 1000usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bitValue_C"][::std::mem::size_of::<bitValue_C>() - 1004usize];
    ["Alignment of bitValue_C"][::std::mem::align_of::<bitValue_C>() - 4usize];
    ["Offset of field: bitValue_C::value"][::std::mem::offset_of!(bitValue_C, value) - 0usize];
    ["Offset of field: bitValue_C::description"]
        [::std::mem::offset_of!(bitValue_C, description) - 4usize];
};
#[doc = " \\struct  bit_C.\n \\brief   This stucture will be filled by values which characterize the device's option bytes.\n \\note    See product reference manual for more details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bit_C {
    #[doc = "< Bit name such as RDP, BOR_LEV, nBOOT0..."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Config description."]
    pub description: [::std::os::raw::c_char; 1000usize],
    #[doc = "< Word offset."]
    pub wordOffset: ::std::os::raw::c_uint,
    #[doc = "< Bit offset."]
    pub bitOffset: ::std::os::raw::c_uint,
    #[doc = "< Number of bits build the option."]
    pub bitWidth: ::std::os::raw::c_uint,
    #[doc = "< Access Read/Write."]
    pub access: ::std::os::raw::c_uchar,
    #[doc = "< Number of possible values."]
    pub valuesNbr: ::std::os::raw::c_uint,
    #[doc = "< Bits value, #BitValue_C."]
    pub values: *mut *mut bitValue_C,
    #[doc = "< Bits equation, #BitCoefficient_C."]
    pub equation: bitCoefficient_C,
    pub reference: *mut ::std::os::raw::c_uchar,
    pub bitValue: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bit_C"][::std::mem::size_of::<bit_C>() - 1120usize];
    ["Alignment of bit_C"][::std::mem::align_of::<bit_C>() - 8usize];
    ["Offset of field: bit_C::name"][::std::mem::offset_of!(bit_C, name) - 0usize];
    ["Offset of field: bit_C::description"][::std::mem::offset_of!(bit_C, description) - 64usize];
    ["Offset of field: bit_C::wordOffset"][::std::mem::offset_of!(bit_C, wordOffset) - 1064usize];
    ["Offset of field: bit_C::bitOffset"][::std::mem::offset_of!(bit_C, bitOffset) - 1068usize];
    ["Offset of field: bit_C::bitWidth"][::std::mem::offset_of!(bit_C, bitWidth) - 1072usize];
    ["Offset of field: bit_C::access"][::std::mem::offset_of!(bit_C, access) - 1076usize];
    ["Offset of field: bit_C::valuesNbr"][::std::mem::offset_of!(bit_C, valuesNbr) - 1080usize];
    ["Offset of field: bit_C::values"][::std::mem::offset_of!(bit_C, values) - 1088usize];
    ["Offset of field: bit_C::equation"][::std::mem::offset_of!(bit_C, equation) - 1096usize];
    ["Offset of field: bit_C::reference"][::std::mem::offset_of!(bit_C, reference) - 1104usize];
    ["Offset of field: bit_C::bitValue"][::std::mem::offset_of!(bit_C, bitValue) - 1112usize];
};
#[doc = " \\struct  category_C\n \\brief   Get option bytes banks categories descriptions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct category_C {
    #[doc = "< Get category name such as Read Out Protection, BOR Level..."]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< Get bits number of the considered category."]
    pub bitsNbr: ::std::os::raw::c_uint,
    #[doc = "< Get internal bits descriptions."]
    pub bits: *mut *mut bit_C,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of category_C"][::std::mem::size_of::<category_C>() - 112usize];
    ["Alignment of category_C"][::std::mem::align_of::<category_C>() - 8usize];
    ["Offset of field: category_C::name"][::std::mem::offset_of!(category_C, name) - 0usize];
    ["Offset of field: category_C::bitsNbr"]
        [::std::mem::offset_of!(category_C, bitsNbr) - 100usize];
    ["Offset of field: category_C::bits"][::std::mem::offset_of!(category_C, bits) - 104usize];
};
#[doc = " \\struct  bank_C\n \\brief   Get option bytes banks internal descriptions.\n \\note    STLINK and Bootloader interfaces have different addresses to access to option bytes registres."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bank_C {
    #[doc = "< Bank size."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< Bank starting address."]
    pub address: ::std::os::raw::c_uint,
    #[doc = "< Bank access Read/Write."]
    pub access: ::std::os::raw::c_uchar,
    #[doc = "< Number of option bytes categories."]
    pub categoriesNbr: ::std::os::raw::c_uint,
    #[doc = "< Get bank categories descriptions #Category_C."]
    pub categories: *mut *mut category_C,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bank_C"][::std::mem::size_of::<bank_C>() - 24usize];
    ["Alignment of bank_C"][::std::mem::align_of::<bank_C>() - 8usize];
    ["Offset of field: bank_C::size"][::std::mem::offset_of!(bank_C, size) - 0usize];
    ["Offset of field: bank_C::address"][::std::mem::offset_of!(bank_C, address) - 4usize];
    ["Offset of field: bank_C::access"][::std::mem::offset_of!(bank_C, access) - 8usize];
    ["Offset of field: bank_C::categoriesNbr"]
        [::std::mem::offset_of!(bank_C, categoriesNbr) - 12usize];
    ["Offset of field: bank_C::categories"][::std::mem::offset_of!(bank_C, categories) - 16usize];
};
#[doc = " \\struct  peripheral_C\n \\brief   Get peripheral option bytes general informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct peripheral_C {
    #[doc = "< Peripheral name."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Peripheral description."]
    pub description: [::std::os::raw::c_char; 1000usize],
    #[doc = "< Number of existed banks."]
    pub banksNbr: ::std::os::raw::c_uint,
    #[doc = "< Get banks descriptions #Bank_C."]
    pub banks: *mut *mut bank_C,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of peripheral_C"][::std::mem::size_of::<peripheral_C>() - 1080usize];
    ["Alignment of peripheral_C"][::std::mem::align_of::<peripheral_C>() - 8usize];
    ["Offset of field: peripheral_C::name"][::std::mem::offset_of!(peripheral_C, name) - 0usize];
    ["Offset of field: peripheral_C::description"]
        [::std::mem::offset_of!(peripheral_C, description) - 64usize];
    ["Offset of field: peripheral_C::banksNbr"]
        [::std::mem::offset_of!(peripheral_C, banksNbr) - 1064usize];
    ["Offset of field: peripheral_C::banks"]
        [::std::mem::offset_of!(peripheral_C, banks) - 1072usize];
};
#[doc = " no messages ever printed by the library"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_NONE: cubeProgrammerVerbosityLevel =
    0;
#[doc = " warning, error and success messages are printed (default)"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_ONE: cubeProgrammerVerbosityLevel =
    1;
#[doc = " error roots informational messages are printed"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_TWO: cubeProgrammerVerbosityLevel =
    2;
#[doc = " debug and informational messages are printed"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_DEBUG:
    cubeProgrammerVerbosityLevel = 3;
#[doc = " no progress bar is printed in the output of the library"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_NO_PROGRESS_BAR:
    cubeProgrammerVerbosityLevel = 4;
#[doc = " \\enum  cubeProgrammerVerbosityLevel\n \\brief List of verbosity levels."]
pub type cubeProgrammerVerbosityLevel = ::std::os::raw::c_int;
#[doc = " Success (no error)"]
pub const cubeProgrammerError_CUBEPROGRAMMER_NO_ERROR: cubeProgrammerError = 0;
#[doc = " Device not connected"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NOT_CONNECTED: cubeProgrammerError = -1;
#[doc = " Device not found"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_DEVICE: cubeProgrammerError = -2;
#[doc = " Device connection error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_CONNECTION: cubeProgrammerError = -3;
#[doc = " No such file"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_FILE: cubeProgrammerError = -4;
#[doc = " Operation not supported or unimplemented on this interface"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NOT_SUPPORTED: cubeProgrammerError = -5;
#[doc = " Interface not supported or unimplemented on this plateform"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_INTERFACE_NOT_SUPPORTED: cubeProgrammerError =
    -6;
#[doc = " Insufficient memory"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_MEM: cubeProgrammerError = -7;
#[doc = " Wrong parameters"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_WRONG_PARAM: cubeProgrammerError = -8;
#[doc = " Memory read failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_READ_MEM: cubeProgrammerError = -9;
#[doc = " Memory write failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_WRITE_MEM: cubeProgrammerError = -10;
#[doc = " Memory erase failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_ERASE_MEM: cubeProgrammerError = -11;
#[doc = " File format not supported for this kind of device"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_UNSUPPORTED_FILE_FORMAT: cubeProgrammerError =
    -12;
#[doc = " Refresh required"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_REFRESH_REQUIRED: cubeProgrammerError = -13;
#[doc = " Refresh required"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_SECURITY: cubeProgrammerError = -14;
#[doc = " Changing frequency problem"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_CHANGE_FREQ: cubeProgrammerError = -15;
#[doc = " RDP Enabled error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_RDP_ENABLED: cubeProgrammerError = -16;
#[doc = " Other error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_OTHER: cubeProgrammerError = -99;
#[doc = " \\enum  cubeProgrammerError\n \\brief List of errors that can be occured."]
pub type cubeProgrammerError = ::std::os::raw::c_int;
pub const flashSize_Flash_Size_1KB: flashSize = 1024;
pub const flashSize_Flash_Size_512KB: flashSize = 524288;
pub const flashSize_Flash_Size_256KB: flashSize = 262144;
pub type flashSize = ::std::os::raw::c_int;
pub const wbFunctionArguments_FIRST_INSTALL_ACTIVE: wbFunctionArguments = 1;
pub const wbFunctionArguments_FIRST_INSTALL_NOT_ACTIVE: wbFunctionArguments = 0;
pub const wbFunctionArguments_START_STACK_ACTIVE: wbFunctionArguments = 1;
pub const wbFunctionArguments_START_STACK_NOT_ACTIVE: wbFunctionArguments = 1;
pub const wbFunctionArguments_VERIFY_FILE_DOWLOAD_FILE: wbFunctionArguments = 1;
pub const wbFunctionArguments_DO_NOT_VERIFY_DOWLOAD_FILE: wbFunctionArguments = 0;
pub type wbFunctionArguments = ::std::os::raw::c_int;
#[doc = "< Even parity bit."]
pub const usartParity_EVEN: usartParity = 0;
#[doc = "< Odd parity bit."]
pub const usartParity_ODD: usartParity = 1;
#[doc = "< No check parity."]
pub const usartParity_NONE: usartParity = 2;
#[doc = " \\enum  usartParity\n \\brief The parity bit in the data frame of the USART communication tells the receiving device if there is any error in the data bits."]
pub type usartParity = ::std::os::raw::c_int;
#[doc = "< No flow control."]
pub const usartFlowControl_OFF: usartFlowControl = 0;
#[doc = "< Hardware flow control : RTS/CTS."]
pub const usartFlowControl_HARDWARE: usartFlowControl = 1;
#[doc = "< Software flow control : Transmission is started and stopped by sending special characters."]
pub const usartFlowControl_SOFTWARE: usartFlowControl = 2;
#[doc = " \\enum  usartFlowControl\n \\brief UART Flow Control is a method for devices to communicate with each other over UART without the risk of losing data."]
pub type usartFlowControl = ::std::os::raw::c_int;
#[doc = " \\struct  dfuDeviceInfo\n \\brief   Get DFU device informations ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dfuDeviceInfo {
    #[doc = "< USB index."]
    pub usbIndex: [::std::os::raw::c_char; 10usize],
    #[doc = "< Bus number."]
    pub busNumber: ::std::os::raw::c_int,
    #[doc = "< Address number."]
    pub addressNumber: ::std::os::raw::c_int,
    #[doc = "< Product number."]
    pub productId: [::std::os::raw::c_char; 100usize],
    #[doc = "< Serial number."]
    pub serialNumber: [::std::os::raw::c_char; 100usize],
    #[doc = "< DFU version."]
    pub dfuVersion: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dfuDeviceInfo"][::std::mem::size_of::<dfuDeviceInfo>() - 224usize];
    ["Alignment of dfuDeviceInfo"][::std::mem::align_of::<dfuDeviceInfo>() - 4usize];
    ["Offset of field: dfuDeviceInfo::usbIndex"]
        [::std::mem::offset_of!(dfuDeviceInfo, usbIndex) - 0usize];
    ["Offset of field: dfuDeviceInfo::busNumber"]
        [::std::mem::offset_of!(dfuDeviceInfo, busNumber) - 12usize];
    ["Offset of field: dfuDeviceInfo::addressNumber"]
        [::std::mem::offset_of!(dfuDeviceInfo, addressNumber) - 16usize];
    ["Offset of field: dfuDeviceInfo::productId"]
        [::std::mem::offset_of!(dfuDeviceInfo, productId) - 20usize];
    ["Offset of field: dfuDeviceInfo::serialNumber"]
        [::std::mem::offset_of!(dfuDeviceInfo, serialNumber) - 120usize];
    ["Offset of field: dfuDeviceInfo::dfuVersion"]
        [::std::mem::offset_of!(dfuDeviceInfo, dfuVersion) - 220usize];
};
#[doc = " \\struct  usartConnectParameters\n \\brief   Specify the USART connect parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usartConnectParameters {
    #[doc = "< Interface identifier: COM1, COM2, /dev/ttyS0..."]
    pub portName: [::std::os::raw::c_char; 100usize],
    #[doc = "< Speed transmission: 115200, 9600..."]
    pub baudrate: ::std::os::raw::c_uint,
    #[doc = "< Parity bit: value in usartParity."]
    pub parity: usartParity,
    #[doc = "< Data bit: value in {6, 7, 8}."]
    pub dataBits: ::std::os::raw::c_uchar,
    #[doc = "< Stop bit: value in {1, 1.5, 2}."]
    pub stopBits: f32,
    #[doc = "< Flow control: value in usartFlowControl."]
    pub flowControl: usartFlowControl,
    #[doc = "< RTS: Value in {0,1}."]
    pub statusRTS: ::std::os::raw::c_int,
    #[doc = "< DTR: Value in {0,1}."]
    pub statusDTR: ::std::os::raw::c_int,
    #[doc = "< Set No Init bits: value in {0,1}."]
    pub noinitBits: ::std::os::raw::c_uchar,
    #[doc = "< request a read unprotect: value in {0,1}."]
    pub rdu: ::std::os::raw::c_char,
    #[doc = "< request a TZEN regression: value in {0,1}."]
    pub tzenreg: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of usartConnectParameters"][::std::mem::size_of::<usartConnectParameters>() - 132usize];
    ["Alignment of usartConnectParameters"]
        [::std::mem::align_of::<usartConnectParameters>() - 4usize];
    ["Offset of field: usartConnectParameters::portName"]
        [::std::mem::offset_of!(usartConnectParameters, portName) - 0usize];
    ["Offset of field: usartConnectParameters::baudrate"]
        [::std::mem::offset_of!(usartConnectParameters, baudrate) - 100usize];
    ["Offset of field: usartConnectParameters::parity"]
        [::std::mem::offset_of!(usartConnectParameters, parity) - 104usize];
    ["Offset of field: usartConnectParameters::dataBits"]
        [::std::mem::offset_of!(usartConnectParameters, dataBits) - 108usize];
    ["Offset of field: usartConnectParameters::stopBits"]
        [::std::mem::offset_of!(usartConnectParameters, stopBits) - 112usize];
    ["Offset of field: usartConnectParameters::flowControl"]
        [::std::mem::offset_of!(usartConnectParameters, flowControl) - 116usize];
    ["Offset of field: usartConnectParameters::statusRTS"]
        [::std::mem::offset_of!(usartConnectParameters, statusRTS) - 120usize];
    ["Offset of field: usartConnectParameters::statusDTR"]
        [::std::mem::offset_of!(usartConnectParameters, statusDTR) - 124usize];
    ["Offset of field: usartConnectParameters::noinitBits"]
        [::std::mem::offset_of!(usartConnectParameters, noinitBits) - 128usize];
    ["Offset of field: usartConnectParameters::rdu"]
        [::std::mem::offset_of!(usartConnectParameters, rdu) - 129usize];
    ["Offset of field: usartConnectParameters::tzenreg"]
        [::std::mem::offset_of!(usartConnectParameters, tzenreg) - 130usize];
};
#[doc = " \\struct  dfuConnectParameters\n \\brief   Specify the USB DFU connect parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dfuConnectParameters {
    pub usb_index: *mut ::std::os::raw::c_char,
    #[doc = "< request a read unprotect: value in {0,1}."]
    pub rdu: ::std::os::raw::c_char,
    #[doc = "< request a TZEN regression: value in {0,1}."]
    pub tzenreg: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dfuConnectParameters"][::std::mem::size_of::<dfuConnectParameters>() - 16usize];
    ["Alignment of dfuConnectParameters"][::std::mem::align_of::<dfuConnectParameters>() - 8usize];
    ["Offset of field: dfuConnectParameters::usb_index"]
        [::std::mem::offset_of!(dfuConnectParameters, usb_index) - 0usize];
    ["Offset of field: dfuConnectParameters::rdu"]
        [::std::mem::offset_of!(dfuConnectParameters, rdu) - 8usize];
    ["Offset of field: dfuConnectParameters::tzenreg"]
        [::std::mem::offset_of!(dfuConnectParameters, tzenreg) - 9usize];
};
#[doc = " \\struct  spiConnectParameters\n \\brief   Specify the SPI connect parameters.\n \\note    Recommended SPI parameters : baudrate=375, crcPol=7, direction=0, cpha=0, cpol=0, crc=0, firstBit=1, frameFormat=0, dataSize=1, mode=1, nss=1, nssPulse=1, delay=1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spiConnectParameters {
    #[doc = "< Speed transmission 187, 375, 750, 1500, 3000, 6000, 12000 KHz."]
    pub baudrate: u32,
    #[doc = "< crc polynom value."]
    pub crcPol: u16,
    #[doc = "< 2LFullDuplex/2LRxOnly/1LRx/1LTx."]
    pub direction: ::std::os::raw::c_int,
    #[doc = "< 1Edge or 2Edge."]
    pub cpha: ::std::os::raw::c_int,
    #[doc = "< LOW or HIGH."]
    pub cpol: ::std::os::raw::c_int,
    #[doc = "< DISABLE or ENABLE."]
    pub crc: ::std::os::raw::c_int,
    #[doc = "< First bit: LSB or MSB."]
    pub firstBit: ::std::os::raw::c_int,
    #[doc = "< Frame format: Motorola or TI."]
    pub frameFormat: ::std::os::raw::c_int,
    #[doc = "< Size of frame data: 16bit or 8bit ."]
    pub dataSize: ::std::os::raw::c_int,
    #[doc = "< Operating mode: Slave or Master."]
    pub mode: ::std::os::raw::c_int,
    #[doc = "< Selection: Soft or Hard."]
    pub nss: ::std::os::raw::c_int,
    #[doc = "< NSS pulse: No Pulse or Pulse."]
    pub nssPulse: ::std::os::raw::c_int,
    #[doc = "< Delay of few microseconds, No Delay or Delay, at least 4us delay is inserted"]
    pub delay: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spiConnectParameters"][::std::mem::size_of::<spiConnectParameters>() - 52usize];
    ["Alignment of spiConnectParameters"][::std::mem::align_of::<spiConnectParameters>() - 4usize];
    ["Offset of field: spiConnectParameters::baudrate"]
        [::std::mem::offset_of!(spiConnectParameters, baudrate) - 0usize];
    ["Offset of field: spiConnectParameters::crcPol"]
        [::std::mem::offset_of!(spiConnectParameters, crcPol) - 4usize];
    ["Offset of field: spiConnectParameters::direction"]
        [::std::mem::offset_of!(spiConnectParameters, direction) - 8usize];
    ["Offset of field: spiConnectParameters::cpha"]
        [::std::mem::offset_of!(spiConnectParameters, cpha) - 12usize];
    ["Offset of field: spiConnectParameters::cpol"]
        [::std::mem::offset_of!(spiConnectParameters, cpol) - 16usize];
    ["Offset of field: spiConnectParameters::crc"]
        [::std::mem::offset_of!(spiConnectParameters, crc) - 20usize];
    ["Offset of field: spiConnectParameters::firstBit"]
        [::std::mem::offset_of!(spiConnectParameters, firstBit) - 24usize];
    ["Offset of field: spiConnectParameters::frameFormat"]
        [::std::mem::offset_of!(spiConnectParameters, frameFormat) - 28usize];
    ["Offset of field: spiConnectParameters::dataSize"]
        [::std::mem::offset_of!(spiConnectParameters, dataSize) - 32usize];
    ["Offset of field: spiConnectParameters::mode"]
        [::std::mem::offset_of!(spiConnectParameters, mode) - 36usize];
    ["Offset of field: spiConnectParameters::nss"]
        [::std::mem::offset_of!(spiConnectParameters, nss) - 40usize];
    ["Offset of field: spiConnectParameters::nssPulse"]
        [::std::mem::offset_of!(spiConnectParameters, nssPulse) - 44usize];
    ["Offset of field: spiConnectParameters::delay"]
        [::std::mem::offset_of!(spiConnectParameters, delay) - 48usize];
};
#[doc = " \\struct  canConnectParameters\n \\brief   Specify the CAN connect parameters.\n \\note    Not all configurations are supported by STM32 Bootloader, such as CAN type is STANDARD and the filter should be always activated.\n \\note    Recommended CAN parameters : br=125000, mode=0, ide=0, rtr=0, fifo=0, fm=0, fs=1, fe=1, fbn=0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canConnectParameters {
    #[doc = "< Baudrate and speed transmission 125KHz, 250KHz, 500KHz..."]
    pub br: ::std::os::raw::c_int,
    #[doc = "< CAN mode: NORMAL, LOOPBACK...,"]
    pub mode: ::std::os::raw::c_int,
    #[doc = "< CAN type: STANDARD or EXTENDED."]
    pub ide: ::std::os::raw::c_int,
    #[doc = "< Frame format: DATA or REMOTE."]
    pub rtr: ::std::os::raw::c_int,
    #[doc = "< Memory of received messages: FIFO0 or FIFO1."]
    pub fifo: ::std::os::raw::c_int,
    #[doc = "< Filter mode: MASK or LIST."]
    pub fm: ::std::os::raw::c_int,
    #[doc = "< Filter scale: 16 or 32."]
    pub fs: ::std::os::raw::c_int,
    #[doc = "< Filter activation: DISABLE or ENABLE."]
    pub fe: ::std::os::raw::c_int,
    #[doc = "< Filter bank number: 0 to 13."]
    pub fbn: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of canConnectParameters"][::std::mem::size_of::<canConnectParameters>() - 36usize];
    ["Alignment of canConnectParameters"][::std::mem::align_of::<canConnectParameters>() - 4usize];
    ["Offset of field: canConnectParameters::br"]
        [::std::mem::offset_of!(canConnectParameters, br) - 0usize];
    ["Offset of field: canConnectParameters::mode"]
        [::std::mem::offset_of!(canConnectParameters, mode) - 4usize];
    ["Offset of field: canConnectParameters::ide"]
        [::std::mem::offset_of!(canConnectParameters, ide) - 8usize];
    ["Offset of field: canConnectParameters::rtr"]
        [::std::mem::offset_of!(canConnectParameters, rtr) - 12usize];
    ["Offset of field: canConnectParameters::fifo"]
        [::std::mem::offset_of!(canConnectParameters, fifo) - 16usize];
    ["Offset of field: canConnectParameters::fm"]
        [::std::mem::offset_of!(canConnectParameters, fm) - 20usize];
    ["Offset of field: canConnectParameters::fs"]
        [::std::mem::offset_of!(canConnectParameters, fs) - 24usize];
    ["Offset of field: canConnectParameters::fe"]
        [::std::mem::offset_of!(canConnectParameters, fe) - 28usize];
    ["Offset of field: canConnectParameters::fbn"]
        [::std::mem::offset_of!(canConnectParameters, fbn) - 32usize];
};
#[doc = " \\struct  i2cConnectParameters\n \\brief   Specify the I2C connect parameters.\n \\warning The Bootloader Slave address varies depending on the device (see AN2606).\n \\note    Not all configurations are supported by STM32 Bootloader, such as address in 7 bits form, analog filter: ENABLE, digital filter: DISABLE.\n \\note    Recommended I2C parameters : add=0x??, br=400, sm=1, am=0, af=1, df=0, dnf=0, rt=0, ft=0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2cConnectParameters {
    #[doc = "< Device address in hex format."]
    pub add: ::std::os::raw::c_int,
    #[doc = "< Baudrate and speed transmission : 100 or 400 KHz."]
    pub br: ::std::os::raw::c_int,
    #[doc = "< Speed Mode: STANDARD or FAST."]
    pub sm: ::std::os::raw::c_int,
    #[doc = "< Address Mode: 7 or 10 bits."]
    pub am: ::std::os::raw::c_int,
    #[doc = "< Analog filter: DISABLE or ENABLE."]
    pub af: ::std::os::raw::c_int,
    #[doc = "< Digital filter: DISABLE or ENABLE."]
    pub df: ::std::os::raw::c_int,
    #[doc = "< Digital noise filter: 0 to 15."]
    pub dnf: ::std::os::raw::c_char,
    #[doc = "< Rise time: 0-1000 for STANDARD speed mode and  0-300 for FAST."]
    pub rt: ::std::os::raw::c_int,
    #[doc = "< Fall time: 0-300 for STANDARD speed mode and  0-300 for FAST."]
    pub ft: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of i2cConnectParameters"][::std::mem::size_of::<i2cConnectParameters>() - 36usize];
    ["Alignment of i2cConnectParameters"][::std::mem::align_of::<i2cConnectParameters>() - 4usize];
    ["Offset of field: i2cConnectParameters::add"]
        [::std::mem::offset_of!(i2cConnectParameters, add) - 0usize];
    ["Offset of field: i2cConnectParameters::br"]
        [::std::mem::offset_of!(i2cConnectParameters, br) - 4usize];
    ["Offset of field: i2cConnectParameters::sm"]
        [::std::mem::offset_of!(i2cConnectParameters, sm) - 8usize];
    ["Offset of field: i2cConnectParameters::am"]
        [::std::mem::offset_of!(i2cConnectParameters, am) - 12usize];
    ["Offset of field: i2cConnectParameters::af"]
        [::std::mem::offset_of!(i2cConnectParameters, af) - 16usize];
    ["Offset of field: i2cConnectParameters::df"]
        [::std::mem::offset_of!(i2cConnectParameters, df) - 20usize];
    ["Offset of field: i2cConnectParameters::dnf"]
        [::std::mem::offset_of!(i2cConnectParameters, dnf) - 24usize];
    ["Offset of field: i2cConnectParameters::rt"]
        [::std::mem::offset_of!(i2cConnectParameters, rt) - 28usize];
    ["Offset of field: i2cConnectParameters::ft"]
        [::std::mem::offset_of!(i2cConnectParameters, ft) - 32usize];
};
#[doc = "< Apply a reset by the software."]
pub const debugResetMode_SOFTWARE_RESET: debugResetMode = 0;
#[doc = "< Apply a reset by the hardware."]
pub const debugResetMode_HARDWARE_RESET: debugResetMode = 1;
#[doc = "< Apply a reset by the internal core peripheral."]
pub const debugResetMode_CORE_RESET: debugResetMode = 2;
#[doc = " \\enum  debugResetMode\n \\brief Choose the way to apply a system reset."]
pub type debugResetMode = ::std::os::raw::c_int;
#[doc = "< Connect with normal mode, the target is reset then halted while the type of reset is selected using the [debugResetMode]."]
pub const debugConnectMode_NORMAL_MODE: debugConnectMode = 0;
#[doc = "< Connect with hotplug mode,  this option allows the user to connect to the target without halt or reset."]
pub const debugConnectMode_HOTPLUG_MODE: debugConnectMode = 1;
#[doc = "< Connect with under reset mode, option allows the user to connect to the target using a reset vector catch before executing any instruction."]
pub const debugConnectMode_UNDER_RESET_MODE: debugConnectMode = 2;
#[doc = "< Connect with power down mode."]
pub const debugConnectMode_POWER_DOWN_MODE: debugConnectMode = 3;
#[doc = "< Connect with pre reset mode."]
pub const debugConnectMode_PRE_RESET_MODE: debugConnectMode = 4;
#[doc = "< Connect with hwRstPulse mode."]
pub const debugConnectMode_hwRstPulse_MODE: debugConnectMode = 5;
#[doc = " \\enum  debugConnectMode\n \\brief Choose the appropriate mode for connection."]
pub type debugConnectMode = ::std::os::raw::c_int;
#[doc = "< JTAG debug port."]
pub const debugPort_JTAG: debugPort = 0;
#[doc = "< SWD debug port."]
pub const debugPort_SWD: debugPort = 1;
#[doc = " \\enum  debugPort\n \\brief Select the debug port interface for connection."]
pub type debugPort = ::std::os::raw::c_int;
#[doc = " \\struct  frequencies\n \\brief   Get supported frequencies for JTAG and SWD ineterfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frequencies {
    #[doc = "<  JTAG frequency."]
    pub jtagFreq: [::std::os::raw::c_uint; 12usize],
    #[doc = "<  Get JTAG supported frequencies."]
    pub jtagFreqNumber: ::std::os::raw::c_uint,
    #[doc = "<  SWD frequency."]
    pub swdFreq: [::std::os::raw::c_uint; 12usize],
    #[doc = "<  Get SWD supported frequencies."]
    pub swdFreqNumber: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of frequencies"][::std::mem::size_of::<frequencies>() - 104usize];
    ["Alignment of frequencies"][::std::mem::align_of::<frequencies>() - 4usize];
    ["Offset of field: frequencies::jtagFreq"]
        [::std::mem::offset_of!(frequencies, jtagFreq) - 0usize];
    ["Offset of field: frequencies::jtagFreqNumber"]
        [::std::mem::offset_of!(frequencies, jtagFreqNumber) - 48usize];
    ["Offset of field: frequencies::swdFreq"]
        [::std::mem::offset_of!(frequencies, swdFreq) - 52usize];
    ["Offset of field: frequencies::swdFreqNumber"]
        [::std::mem::offset_of!(frequencies, swdFreqNumber) - 100usize];
};
#[doc = " \\struct  debugConnectParameters\n \\brief   Get device characterization and specify connection parameters through ST-LINK interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debugConnectParameters {
    #[doc = "< Select the type of debug interface #debugPort."]
    pub dbgPort: debugPort,
    #[doc = "< Select one of the debug ports connected."]
    pub index: ::std::os::raw::c_int,
    #[doc = "< ST-LINK serial number."]
    pub serialNumber: [::std::os::raw::c_char; 33usize],
    #[doc = "< Firmware version."]
    pub firmwareVersion: [::std::os::raw::c_char; 20usize],
    #[doc = "< Operate voltage."]
    pub targetVoltage: [::std::os::raw::c_char; 5usize],
    #[doc = "< Number of available access port."]
    pub accessPortNumber: ::std::os::raw::c_int,
    #[doc = "< Select access port controller."]
    pub accessPort: ::std::os::raw::c_int,
    #[doc = "< Select the debug CONNECT mode #debugConnectMode."]
    pub connectionMode: debugConnectMode,
    #[doc = "< Select the debug RESET mode #debugResetMode."]
    pub resetMode: debugResetMode,
    #[doc = "< Check Old ST-LINK firmware version."]
    pub isOldFirmware: ::std::os::raw::c_int,
    #[doc = "< Supported frequencies #frequencies."]
    pub freq: frequencies,
    #[doc = "< Select specific frequency."]
    pub frequency: ::std::os::raw::c_int,
    #[doc = "< Indicates if it's Bridge device or not."]
    pub isBridge: ::std::os::raw::c_int,
    #[doc = "< Select connection type, if it's shared, use ST-LINK Server."]
    pub shared: ::std::os::raw::c_int,
    #[doc = "< board Name"]
    pub board: [::std::os::raw::c_char; 100usize],
    pub DBG_Sleep: ::std::os::raw::c_int,
    #[doc = "< Select speed flashing of Cortex M33 series."]
    pub speed: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of debugConnectParameters"][::std::mem::size_of::<debugConnectParameters>() - 312usize];
    ["Alignment of debugConnectParameters"]
        [::std::mem::align_of::<debugConnectParameters>() - 4usize];
    ["Offset of field: debugConnectParameters::dbgPort"]
        [::std::mem::offset_of!(debugConnectParameters, dbgPort) - 0usize];
    ["Offset of field: debugConnectParameters::index"]
        [::std::mem::offset_of!(debugConnectParameters, index) - 4usize];
    ["Offset of field: debugConnectParameters::serialNumber"]
        [::std::mem::offset_of!(debugConnectParameters, serialNumber) - 8usize];
    ["Offset of field: debugConnectParameters::firmwareVersion"]
        [::std::mem::offset_of!(debugConnectParameters, firmwareVersion) - 41usize];
    ["Offset of field: debugConnectParameters::targetVoltage"]
        [::std::mem::offset_of!(debugConnectParameters, targetVoltage) - 61usize];
    ["Offset of field: debugConnectParameters::accessPortNumber"]
        [::std::mem::offset_of!(debugConnectParameters, accessPortNumber) - 68usize];
    ["Offset of field: debugConnectParameters::accessPort"]
        [::std::mem::offset_of!(debugConnectParameters, accessPort) - 72usize];
    ["Offset of field: debugConnectParameters::connectionMode"]
        [::std::mem::offset_of!(debugConnectParameters, connectionMode) - 76usize];
    ["Offset of field: debugConnectParameters::resetMode"]
        [::std::mem::offset_of!(debugConnectParameters, resetMode) - 80usize];
    ["Offset of field: debugConnectParameters::isOldFirmware"]
        [::std::mem::offset_of!(debugConnectParameters, isOldFirmware) - 84usize];
    ["Offset of field: debugConnectParameters::freq"]
        [::std::mem::offset_of!(debugConnectParameters, freq) - 88usize];
    ["Offset of field: debugConnectParameters::frequency"]
        [::std::mem::offset_of!(debugConnectParameters, frequency) - 192usize];
    ["Offset of field: debugConnectParameters::isBridge"]
        [::std::mem::offset_of!(debugConnectParameters, isBridge) - 196usize];
    ["Offset of field: debugConnectParameters::shared"]
        [::std::mem::offset_of!(debugConnectParameters, shared) - 200usize];
    ["Offset of field: debugConnectParameters::board"]
        [::std::mem::offset_of!(debugConnectParameters, board) - 204usize];
    ["Offset of field: debugConnectParameters::DBG_Sleep"]
        [::std::mem::offset_of!(debugConnectParameters, DBG_Sleep) - 304usize];
    ["Offset of field: debugConnectParameters::speed"]
        [::std::mem::offset_of!(debugConnectParameters, speed) - 308usize];
};
#[doc = "< STLINK used as connection interface."]
pub const targetInterfaceType_STLINK_INTERFACE: targetInterfaceType = 0;
#[doc = "< USART used as connection interface."]
pub const targetInterfaceType_USART_INTERFACE: targetInterfaceType = 1;
#[doc = "< USB DFU used as connection interface."]
pub const targetInterfaceType_USB_INTERFACE: targetInterfaceType = 2;
#[doc = "< SPI used as connection interface."]
pub const targetInterfaceType_SPI_INTERFACE: targetInterfaceType = 3;
#[doc = "< I2C used as connection interface."]
pub const targetInterfaceType_I2C_INTERFACE: targetInterfaceType = 4;
#[doc = "< CAN used as connection interface."]
pub const targetInterfaceType_CAN_INTERFACE: targetInterfaceType = 5;
#[doc = "< JLINK used as connection interface."]
pub const targetInterfaceType_JLINK_INTERFACE: targetInterfaceType = 6;
#[doc = " \\enum  targetInterfaceType\n \\brief Indicates the supported interfaces."]
pub type targetInterfaceType = ::std::os::raw::c_int;
#[doc = " \\struct  displayCallBacks\n \\brief   Functions must be implemented to personalize the display of messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct displayCallBacks {
    #[doc = "< Add a progress bar."]
    pub initProgressBar: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "< Display internal messages according to verbosity level."]
    pub logMessage: ::std::option::Option<
        unsafe extern "C" fn(msgType: ::std::os::raw::c_int, str_: *const u16),
    >,
    #[doc = "< Display the loading of read/write process."]
    pub loadBar: ::std::option::Option<
        unsafe extern "C" fn(x: ::std::os::raw::c_int, n: ::std::os::raw::c_int),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of displayCallBacks"][::std::mem::size_of::<displayCallBacks>() - 24usize];
    ["Alignment of displayCallBacks"][::std::mem::align_of::<displayCallBacks>() - 8usize];
    ["Offset of field: displayCallBacks::initProgressBar"]
        [::std::mem::offset_of!(displayCallBacks, initProgressBar) - 0usize];
    ["Offset of field: displayCallBacks::logMessage"]
        [::std::mem::offset_of!(displayCallBacks, logMessage) - 8usize];
    ["Offset of field: displayCallBacks::loadBar"]
        [::std::mem::offset_of!(displayCallBacks, loadBar) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segmentData_C {
    #[doc = "< Segment start address."]
    pub address: ::std::os::raw::c_int,
    #[doc = "< Memory segment size."]
    pub size: ::std::os::raw::c_int,
    #[doc = "< Memory segment data."]
    pub data: *mut ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of segmentData_C"][::std::mem::size_of::<segmentData_C>() - 16usize];
    ["Alignment of segmentData_C"][::std::mem::align_of::<segmentData_C>() - 8usize];
    ["Offset of field: segmentData_C::address"]
        [::std::mem::offset_of!(segmentData_C, address) - 0usize];
    ["Offset of field: segmentData_C::size"][::std::mem::offset_of!(segmentData_C, size) - 4usize];
    ["Offset of field: segmentData_C::data"][::std::mem::offset_of!(segmentData_C, data) - 8usize];
};
#[doc = " \\struct  FileData_C\n \\brief   Get file required informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fileData_C {
    #[doc = "< File extension type."]
    pub Type: ::std::os::raw::c_int,
    #[doc = "< Number of required segments."]
    pub segmentsNbr: ::std::os::raw::c_int,
    #[doc = "< Segments description."]
    pub segments: *mut segmentData_C,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fileData_C"][::std::mem::size_of::<fileData_C>() - 16usize];
    ["Alignment of fileData_C"][::std::mem::align_of::<fileData_C>() - 8usize];
    ["Offset of field: fileData_C::Type"][::std::mem::offset_of!(fileData_C, Type) - 0usize];
    ["Offset of field: fileData_C::segmentsNbr"]
        [::std::mem::offset_of!(fileData_C, segmentsNbr) - 4usize];
    ["Offset of field: fileData_C::segments"]
        [::std::mem::offset_of!(fileData_C, segments) - 8usize];
};
#[doc = " \\struct  GeneralInf\n \\brief   Get device general informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct generalInf {
    #[doc = "< Device ID."]
    pub deviceId: ::std::os::raw::c_ushort,
    #[doc = "< Flash memory size."]
    pub flashSize: ::std::os::raw::c_int,
    #[doc = "< Bootloader version"]
    pub bootloaderVersion: ::std::os::raw::c_int,
    #[doc = "< Device MCU or MPU."]
    pub type_: [::std::os::raw::c_char; 4usize],
    #[doc = "< Cortex CPU."]
    pub cpu: [::std::os::raw::c_char; 20usize],
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< Device serie."]
    pub series: [::std::os::raw::c_char; 100usize],
    #[doc = "< Take notice."]
    pub description: [::std::os::raw::c_char; 150usize],
    #[doc = "< Revision ID."]
    pub revisionId: [::std::os::raw::c_char; 8usize],
    #[doc = "< Board Rpn."]
    pub board: [::std::os::raw::c_char; 100usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of generalInf"][::std::mem::size_of::<generalInf>() - 496usize];
    ["Alignment of generalInf"][::std::mem::align_of::<generalInf>() - 4usize];
    ["Offset of field: generalInf::deviceId"]
        [::std::mem::offset_of!(generalInf, deviceId) - 0usize];
    ["Offset of field: generalInf::flashSize"]
        [::std::mem::offset_of!(generalInf, flashSize) - 4usize];
    ["Offset of field: generalInf::bootloaderVersion"]
        [::std::mem::offset_of!(generalInf, bootloaderVersion) - 8usize];
    ["Offset of field: generalInf::type_"][::std::mem::offset_of!(generalInf, type_) - 12usize];
    ["Offset of field: generalInf::cpu"][::std::mem::offset_of!(generalInf, cpu) - 16usize];
    ["Offset of field: generalInf::name"][::std::mem::offset_of!(generalInf, name) - 36usize];
    ["Offset of field: generalInf::series"][::std::mem::offset_of!(generalInf, series) - 136usize];
    ["Offset of field: generalInf::description"]
        [::std::mem::offset_of!(generalInf, description) - 236usize];
    ["Offset of field: generalInf::revisionId"]
        [::std::mem::offset_of!(generalInf, revisionId) - 386usize];
    ["Offset of field: generalInf::board"][::std::mem::offset_of!(generalInf, board) - 394usize];
};
#[doc = " \\struct  deviceSector\n \\brief   Get device sectors basic informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct deviceSector {
    #[doc = "< Number of Sectors."]
    pub sectorNum: u32,
    #[doc = "< Sector Size in BYTEs."]
    pub sectorSize: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of deviceSector"][::std::mem::size_of::<deviceSector>() - 8usize];
    ["Alignment of deviceSector"][::std::mem::align_of::<deviceSector>() - 4usize];
    ["Offset of field: deviceSector::sectorNum"]
        [::std::mem::offset_of!(deviceSector, sectorNum) - 0usize];
    ["Offset of field: deviceSector::sectorSize"]
        [::std::mem::offset_of!(deviceSector, sectorSize) - 4usize];
};
#[doc = " \\struct  externalLoader\n \\brief   Get external Loader parameters to launch the process of programming an external flash memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct externalLoader {
    #[doc = "< FlashLoader file path."]
    pub filePath: [::std::os::raw::c_char; 200usize],
    #[doc = "< Device Name and Description."]
    pub deviceName: [::std::os::raw::c_char; 100usize],
    #[doc = "< Device Type: ONCHIP, EXT8BIT, EXT16BIT, ..."]
    pub deviceType: ::std::os::raw::c_int,
    #[doc = "< Default Device Start Address."]
    pub deviceStartAddress: u32,
    #[doc = "< Total Size of Device."]
    pub deviceSize: u32,
    #[doc = "< Programming Page Size."]
    pub pageSize: u32,
    #[doc = "< Type number."]
    pub sectorsTypeNbr: u32,
    #[doc = "< Device sectors."]
    pub sectors: *mut deviceSector,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of externalLoader"][::std::mem::size_of::<externalLoader>() - 328usize];
    ["Alignment of externalLoader"][::std::mem::align_of::<externalLoader>() - 8usize];
    ["Offset of field: externalLoader::filePath"]
        [::std::mem::offset_of!(externalLoader, filePath) - 0usize];
    ["Offset of field: externalLoader::deviceName"]
        [::std::mem::offset_of!(externalLoader, deviceName) - 200usize];
    ["Offset of field: externalLoader::deviceType"]
        [::std::mem::offset_of!(externalLoader, deviceType) - 300usize];
    ["Offset of field: externalLoader::deviceStartAddress"]
        [::std::mem::offset_of!(externalLoader, deviceStartAddress) - 304usize];
    ["Offset of field: externalLoader::deviceSize"]
        [::std::mem::offset_of!(externalLoader, deviceSize) - 308usize];
    ["Offset of field: externalLoader::pageSize"]
        [::std::mem::offset_of!(externalLoader, pageSize) - 312usize];
    ["Offset of field: externalLoader::sectorsTypeNbr"]
        [::std::mem::offset_of!(externalLoader, sectorsTypeNbr) - 316usize];
    ["Offset of field: externalLoader::sectors"]
        [::std::mem::offset_of!(externalLoader, sectors) - 320usize];
};
#[doc = " \\struct  externalStorageInfo\n \\brief   Get external storage informations useful for external Loader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct externalStorageInfo {
    pub externalLoaderNbr: ::std::os::raw::c_uint,
    pub externalLoader: *mut externalLoader,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of externalStorageInfo"][::std::mem::size_of::<externalStorageInfo>() - 16usize];
    ["Alignment of externalStorageInfo"][::std::mem::align_of::<externalStorageInfo>() - 8usize];
    ["Offset of field: externalStorageInfo::externalLoaderNbr"]
        [::std::mem::offset_of!(externalStorageInfo, externalLoaderNbr) - 0usize];
    ["Offset of field: externalStorageInfo::externalLoader"]
        [::std::mem::offset_of!(externalStorageInfo, externalLoader) - 8usize];
};
pub struct CubeProgrammer_API {
    __library: ::libloading::Library,
    pub __va_start: Result<unsafe extern "C" fn(arg1: *mut va_list, ...), ::libloading::Error>,
    pub __security_init_cookie: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub __security_check_cookie:
        Result<unsafe extern "C" fn(_StackCookie: usize), ::libloading::Error>,
    pub __report_gsfailure:
        Result<unsafe extern "C" fn(_StackCookie: usize) -> !, ::libloading::Error>,
    pub __security_cookie: Result<*mut usize, ::libloading::Error>,
    pub getStLinkList: Result<
        unsafe extern "C" fn(
            stLinkList: *mut *mut debugConnectParameters,
            shared: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getStLinkEnumerationList: Result<
        unsafe extern "C" fn(
            stlink_list: *mut *mut debugConnectParameters,
            shared: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectStLink: Result<
        unsafe extern "C" fn(debugParameters: debugConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub reset: Result<
        unsafe extern "C" fn(rstMode: debugResetMode) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getUsartList: Result<
        unsafe extern "C" fn(usartList: *mut *mut usartConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectUsartBootloader: Result<
        unsafe extern "C" fn(usartParameters: usartConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub sendByteUart: Result<
        unsafe extern "C" fn(byte: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getDfuDeviceList: Result<
        unsafe extern "C" fn(
            dfuList: *mut *mut dfuDeviceInfo,
            iPID: ::std::os::raw::c_int,
            iVID: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectDfuBootloader: Result<
        unsafe extern "C" fn(usbIndex: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectDfuBootloader2: Result<
        unsafe extern "C" fn(dfuParameters: dfuConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectSpiBootloader: Result<
        unsafe extern "C" fn(spiParameters: spiConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectCanBootloader: Result<
        unsafe extern "C" fn(canParameters: canConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub connectI2cBootloader: Result<
        unsafe extern "C" fn(i2cParameters: i2cConnectParameters) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub setDisplayCallbacks: Result<unsafe extern "C" fn(c: displayCallBacks), ::libloading::Error>,
    pub setVerbosityLevel:
        Result<unsafe extern "C" fn(level: ::std::os::raw::c_int), ::libloading::Error>,
    pub checkDeviceConnection:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub getDeviceGeneralInf: Result<unsafe extern "C" fn() -> *mut generalInf, ::libloading::Error>,
    pub readMemory: Result<
        unsafe extern "C" fn(
            address: ::std::os::raw::c_uint,
            data: *mut *mut ::std::os::raw::c_uchar,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub writeMemory: Result<
        unsafe extern "C" fn(
            address: ::std::os::raw::c_uint,
            data: *mut ::std::os::raw::c_char,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub editSector: Result<
        unsafe extern "C" fn(
            address: ::std::os::raw::c_uint,
            data: *mut ::std::os::raw::c_char,
            size: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub downloadFile: Result<
        unsafe extern "C" fn(
            filePath: *const u16,
            address: ::std::os::raw::c_uint,
            skipErase: ::std::os::raw::c_uint,
            verify: ::std::os::raw::c_uint,
            binPath: *const u16,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub execute: Result<
        unsafe extern "C" fn(address: ::std::os::raw::c_uint) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub massErase: Result<
        unsafe extern "C" fn(sFlashMemName: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub sectorErase: Result<
        unsafe extern "C" fn(
            sectors: *mut ::std::os::raw::c_uint,
            sectorNbr: ::std::os::raw::c_uint,
            sFlashMemName: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub readUnprotect: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub tzenRegression:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub getTargetInterfaceType:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub getCancelPointer:
        Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_int, ::libloading::Error>,
    pub fileOpen: Result<
        unsafe extern "C" fn(filePath: *const u16) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub freeFileData: Result<unsafe extern "C" fn(data: *mut fileData_C), ::libloading::Error>,
    pub freeLibraryMemory:
        Result<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void), ::libloading::Error>,
    pub verify: Result<
        unsafe extern "C" fn(
            fileData: *mut fileData_C,
            address: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub saveFileToFile: Result<
        unsafe extern "C" fn(
            fileData: *mut fileData_C,
            sFileName: *const u16,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub saveMemoryToFile: Result<
        unsafe extern "C" fn(
            address: ::std::os::raw::c_int,
            size: ::std::os::raw::c_int,
            sFileName: *const u16,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub disconnect: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub deleteInterfaceList: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub automaticMode: Result<
        unsafe extern "C" fn(
            filePath: *const u16,
            address: ::std::os::raw::c_uint,
            skipErase: ::std::os::raw::c_uint,
            verify: ::std::os::raw::c_uint,
            isMassErase: ::std::os::raw::c_int,
            obCommand: *mut ::std::os::raw::c_char,
            run: ::std::os::raw::c_int,
        ),
        ::libloading::Error,
    >,
    pub serialNumberingAutomaticMode: Result<
        unsafe extern "C" fn(
            filePath: *const u16,
            address: ::std::os::raw::c_uint,
            skipErase: ::std::os::raw::c_uint,
            verify: ::std::os::raw::c_uint,
            isMassErase: ::std::os::raw::c_int,
            obCommand: *mut ::std::os::raw::c_char,
            run: ::std::os::raw::c_int,
            enableSerialNumbering: ::std::os::raw::c_int,
            serialAddress: ::std::os::raw::c_int,
            serialSize: ::std::os::raw::c_int,
            serialInitialData: *mut ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub getStorageStructure: Result<
        unsafe extern "C" fn(
            deviceStorageStruct: *mut *mut storageStructure,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub sendOptionBytesCmd: Result<
        unsafe extern "C" fn(command: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub initOptionBytesInterface:
        Result<unsafe extern "C" fn() -> *mut peripheral_C, ::libloading::Error>,
    pub fastRomInitOptionBytesInterface:
        Result<unsafe extern "C" fn(deviceId: u16) -> *mut peripheral_C, ::libloading::Error>,
    pub obDisplay: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub setLoadersPath:
        Result<unsafe extern "C" fn(path: *const ::std::os::raw::c_char), ::libloading::Error>,
    pub setExternalLoaderPath: Result<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            externalLoaderInfo: *mut *mut externalLoader,
        ),
        ::libloading::Error,
    >,
    pub setExternalLoaderOBL: Result<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            externalLoaderInfo: *mut *mut externalLoader,
        ),
        ::libloading::Error,
    >,
    pub getExternalLoaders: Result<
        unsafe extern "C" fn(
            path: *const ::std::os::raw::c_char,
            externalStorageNfo: *mut *mut externalStorageInfo,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub removeExternalLoader:
        Result<unsafe extern "C" fn(path: *const ::std::os::raw::c_char), ::libloading::Error>,
    pub deleteLoaders: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub getUID64: Result<
        unsafe extern "C" fn(data: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub firmwareDelete:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub firmwareUpgrade: Result<
        unsafe extern "C" fn(
            filePath: *const u16,
            address: ::std::os::raw::c_uint,
            firstInstall: ::std::os::raw::c_uint,
            startStack: ::std::os::raw::c_uint,
            verify: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub startWirelessStack:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub updateAuthKey: Result<
        unsafe extern "C" fn(filePath: *const u16) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub authKeyLock: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub writeUserKey: Result<
        unsafe extern "C" fn(
            filePath: *const u16,
            keyType: ::std::os::raw::c_uchar,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub antiRollBack: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub startFus: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub unlockchip: Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub programSsp: Result<
        unsafe extern "C" fn(
            sspFile: *const u16,
            licenseFile: *const u16,
            tfaFile: *const u16,
            hsmSlotId: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub getHsmFirmwareID: Result<
        unsafe extern "C" fn(hsmSlotId: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub getHsmCounter: Result<
        unsafe extern "C" fn(hsmSlotId: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong,
        ::libloading::Error,
    >,
    pub getHsmState: Result<
        unsafe extern "C" fn(hsmSlotId: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub getHsmVersion: Result<
        unsafe extern "C" fn(hsmSlotId: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub getHsmType: Result<
        unsafe extern "C" fn(hsmSlotId: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub getHsmLicense: Result<
        unsafe extern "C" fn(
            hsmSlotId: ::std::os::raw::c_int,
            outLicensePath: *const u16,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub writeCortexRegistres: Result<
        unsafe extern "C" fn(
            reg: ::std::os::raw::c_uint,
            data: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub readCortexReg: Result<
        unsafe extern "C" fn(
            reg: ::std::os::raw::c_uint,
            data: *mut ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
}
impl CubeProgrammer_API {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let __va_start = __library.get(b"__va_start\0").map(|sym| *sym);
        let __security_init_cookie = __library.get(b"__security_init_cookie\0").map(|sym| *sym);
        let __security_check_cookie = __library.get(b"__security_check_cookie\0").map(|sym| *sym);
        let __report_gsfailure = __library.get(b"__report_gsfailure\0").map(|sym| *sym);
        let __security_cookie = __library
            .get::<*mut usize>(b"__security_cookie\0")
            .map(|sym| *sym);
        let getStLinkList = __library.get(b"getStLinkList\0").map(|sym| *sym);
        let getStLinkEnumerationList = __library.get(b"getStLinkEnumerationList\0").map(|sym| *sym);
        let connectStLink = __library.get(b"connectStLink\0").map(|sym| *sym);
        let reset = __library.get(b"reset\0").map(|sym| *sym);
        let getUsartList = __library.get(b"getUsartList\0").map(|sym| *sym);
        let connectUsartBootloader = __library.get(b"connectUsartBootloader\0").map(|sym| *sym);
        let sendByteUart = __library.get(b"sendByteUart\0").map(|sym| *sym);
        let getDfuDeviceList = __library.get(b"getDfuDeviceList\0").map(|sym| *sym);
        let connectDfuBootloader = __library.get(b"connectDfuBootloader\0").map(|sym| *sym);
        let connectDfuBootloader2 = __library.get(b"connectDfuBootloader2\0").map(|sym| *sym);
        let connectSpiBootloader = __library.get(b"connectSpiBootloader\0").map(|sym| *sym);
        let connectCanBootloader = __library.get(b"connectCanBootloader\0").map(|sym| *sym);
        let connectI2cBootloader = __library.get(b"connectI2cBootloader\0").map(|sym| *sym);
        let setDisplayCallbacks = __library.get(b"setDisplayCallbacks\0").map(|sym| *sym);
        let setVerbosityLevel = __library.get(b"setVerbosityLevel\0").map(|sym| *sym);
        let checkDeviceConnection = __library.get(b"checkDeviceConnection\0").map(|sym| *sym);
        let getDeviceGeneralInf = __library.get(b"getDeviceGeneralInf\0").map(|sym| *sym);
        let readMemory = __library.get(b"readMemory\0").map(|sym| *sym);
        let writeMemory = __library.get(b"writeMemory\0").map(|sym| *sym);
        let editSector = __library.get(b"editSector\0").map(|sym| *sym);
        let downloadFile = __library.get(b"downloadFile\0").map(|sym| *sym);
        let execute = __library.get(b"execute\0").map(|sym| *sym);
        let massErase = __library.get(b"massErase\0").map(|sym| *sym);
        let sectorErase = __library.get(b"sectorErase\0").map(|sym| *sym);
        let readUnprotect = __library.get(b"readUnprotect\0").map(|sym| *sym);
        let tzenRegression = __library.get(b"tzenRegression\0").map(|sym| *sym);
        let getTargetInterfaceType = __library.get(b"getTargetInterfaceType\0").map(|sym| *sym);
        let getCancelPointer = __library.get(b"getCancelPointer\0").map(|sym| *sym);
        let fileOpen = __library.get(b"fileOpen\0").map(|sym| *sym);
        let freeFileData = __library.get(b"freeFileData\0").map(|sym| *sym);
        let freeLibraryMemory = __library.get(b"freeLibraryMemory\0").map(|sym| *sym);
        let verify = __library.get(b"verify\0").map(|sym| *sym);
        let saveFileToFile = __library.get(b"saveFileToFile\0").map(|sym| *sym);
        let saveMemoryToFile = __library.get(b"saveMemoryToFile\0").map(|sym| *sym);
        let disconnect = __library.get(b"disconnect\0").map(|sym| *sym);
        let deleteInterfaceList = __library.get(b"deleteInterfaceList\0").map(|sym| *sym);
        let automaticMode = __library.get(b"automaticMode\0").map(|sym| *sym);
        let serialNumberingAutomaticMode = __library
            .get(b"serialNumberingAutomaticMode\0")
            .map(|sym| *sym);
        let getStorageStructure = __library.get(b"getStorageStructure\0").map(|sym| *sym);
        let sendOptionBytesCmd = __library.get(b"sendOptionBytesCmd\0").map(|sym| *sym);
        let initOptionBytesInterface = __library.get(b"initOptionBytesInterface\0").map(|sym| *sym);
        let fastRomInitOptionBytesInterface = __library
            .get(b"fastRomInitOptionBytesInterface\0")
            .map(|sym| *sym);
        let obDisplay = __library.get(b"obDisplay\0").map(|sym| *sym);
        let setLoadersPath = __library.get(b"setLoadersPath\0").map(|sym| *sym);
        let setExternalLoaderPath = __library.get(b"setExternalLoaderPath\0").map(|sym| *sym);
        let setExternalLoaderOBL = __library.get(b"setExternalLoaderOBL\0").map(|sym| *sym);
        let getExternalLoaders = __library.get(b"getExternalLoaders\0").map(|sym| *sym);
        let removeExternalLoader = __library.get(b"removeExternalLoader\0").map(|sym| *sym);
        let deleteLoaders = __library.get(b"deleteLoaders\0").map(|sym| *sym);
        let getUID64 = __library.get(b"getUID64\0").map(|sym| *sym);
        let firmwareDelete = __library.get(b"firmwareDelete\0").map(|sym| *sym);
        let firmwareUpgrade = __library.get(b"firmwareUpgrade\0").map(|sym| *sym);
        let startWirelessStack = __library.get(b"startWirelessStack\0").map(|sym| *sym);
        let updateAuthKey = __library.get(b"updateAuthKey\0").map(|sym| *sym);
        let authKeyLock = __library.get(b"authKeyLock\0").map(|sym| *sym);
        let writeUserKey = __library.get(b"writeUserKey\0").map(|sym| *sym);
        let antiRollBack = __library.get(b"antiRollBack\0").map(|sym| *sym);
        let startFus = __library.get(b"startFus\0").map(|sym| *sym);
        let unlockchip = __library.get(b"unlockchip\0").map(|sym| *sym);
        let programSsp = __library.get(b"programSsp\0").map(|sym| *sym);
        let getHsmFirmwareID = __library.get(b"getHsmFirmwareID\0").map(|sym| *sym);
        let getHsmCounter = __library.get(b"getHsmCounter\0").map(|sym| *sym);
        let getHsmState = __library.get(b"getHsmState\0").map(|sym| *sym);
        let getHsmVersion = __library.get(b"getHsmVersion\0").map(|sym| *sym);
        let getHsmType = __library.get(b"getHsmType\0").map(|sym| *sym);
        let getHsmLicense = __library.get(b"getHsmLicense\0").map(|sym| *sym);
        let writeCortexRegistres = __library.get(b"writeCortexRegistres\0").map(|sym| *sym);
        let readCortexReg = __library.get(b"readCortexReg\0").map(|sym| *sym);
        Ok(CubeProgrammer_API {
            __library,
            __va_start,
            __security_init_cookie,
            __security_check_cookie,
            __report_gsfailure,
            __security_cookie,
            getStLinkList,
            getStLinkEnumerationList,
            connectStLink,
            reset,
            getUsartList,
            connectUsartBootloader,
            sendByteUart,
            getDfuDeviceList,
            connectDfuBootloader,
            connectDfuBootloader2,
            connectSpiBootloader,
            connectCanBootloader,
            connectI2cBootloader,
            setDisplayCallbacks,
            setVerbosityLevel,
            checkDeviceConnection,
            getDeviceGeneralInf,
            readMemory,
            writeMemory,
            editSector,
            downloadFile,
            execute,
            massErase,
            sectorErase,
            readUnprotect,
            tzenRegression,
            getTargetInterfaceType,
            getCancelPointer,
            fileOpen,
            freeFileData,
            freeLibraryMemory,
            verify,
            saveFileToFile,
            saveMemoryToFile,
            disconnect,
            deleteInterfaceList,
            automaticMode,
            serialNumberingAutomaticMode,
            getStorageStructure,
            sendOptionBytesCmd,
            initOptionBytesInterface,
            fastRomInitOptionBytesInterface,
            obDisplay,
            setLoadersPath,
            setExternalLoaderPath,
            setExternalLoaderOBL,
            getExternalLoaders,
            removeExternalLoader,
            deleteLoaders,
            getUID64,
            firmwareDelete,
            firmwareUpgrade,
            startWirelessStack,
            updateAuthKey,
            authKeyLock,
            writeUserKey,
            antiRollBack,
            startFus,
            unlockchip,
            programSsp,
            getHsmFirmwareID,
            getHsmCounter,
            getHsmState,
            getHsmVersion,
            getHsmType,
            getHsmLicense,
            writeCortexRegistres,
            readCortexReg,
        })
    }
    pub unsafe fn __security_init_cookie(&self) {
        (self
            .__security_init_cookie
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn __security_check_cookie(&self, _StackCookie: usize) {
        (self
            .__security_check_cookie
            .as_ref()
            .expect("Expected function, got error."))(_StackCookie)
    }
    pub unsafe fn __report_gsfailure(&self, _StackCookie: usize) -> ! {
        (self
            .__report_gsfailure
            .as_ref()
            .expect("Expected function, got error."))(_StackCookie)
    }
    pub unsafe fn __security_cookie(&self) -> *mut usize {
        *self
            .__security_cookie
            .as_ref()
            .expect("Expected variable, got error.")
    }
    #[doc = " \\brief This routine allows to get ST-LINK conneted probe(s).\n \\param stLinkList  : Filled with the connected ST-LINK list and its default configurations.\n \\param shared      : Enable shared mode allowing connection of two or more instances to the same ST-LINK probe.\n \\return Number of the ST-LINK probes already exists.\n \\warning The Share option is useful only with ST-LINK Server.\n \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub unsafe fn getStLinkList(
        &self,
        stLinkList: *mut *mut debugConnectParameters,
        shared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .getStLinkList
            .as_ref()
            .expect("Expected function, got error."))(stLinkList, shared)
    }
    #[doc = " \\brief This routine allows to get ST-LINK conneted probe(s) without connecting and intruse the target.\n \\param stLinkList  : Filled with the connected ST-LINK list and its default configurations.\n \\param shared      : Enable shared mode allowing connection of two or more instances to the same ST-LINK probe.\n \\return Number of the ST-LINK probes already exists.\n \\warning The Share option is useful only with ST-LINK Server.\n \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub unsafe fn getStLinkEnumerationList(
        &self,
        stlink_list: *mut *mut debugConnectParameters,
        shared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .getStLinkEnumerationList
            .as_ref()
            .expect("Expected function, got error."))(stlink_list, shared)
    }
    #[doc = " \\brief This routine allows to start connection to device through SWD or JTAG interfaces.\n \\param debugParameters : Indicates customized configuration for ST-LINK connection,\n It is recommended to check [debugConnectParameters] fields before connection.\n \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub unsafe fn connectStLink(
        &self,
        debugParameters: debugConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectStLink
            .as_ref()
            .expect("Expected function, got error."))(debugParameters)
    }
    #[doc = " \\brief This routine used to apply a target reset.\n \\note  Reset operation is only available with JTAG/SWD debug interface.\n \\param rstMode : Indicates the reset type Soft/Hard/Core #debugResetMode. \\n\n \\return 0 if the reset operation finished successfully, otherwise an error occurred."]
    pub unsafe fn reset(&self, rstMode: debugResetMode) -> ::std::os::raw::c_int {
        (self.reset.as_ref().expect("Expected function, got error."))(rstMode)
    }
    #[doc = " \\brief This routine allows to get connected serial ports.\n \\param usartList : Receive serial ports list and its default configurations.\n \\return Number of serial ports already connected.\n \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub unsafe fn getUsartList(
        &self,
        usartList: *mut *mut usartConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .getUsartList
            .as_ref()
            .expect("Expected function, got error."))(usartList)
    }
    #[doc = " \\brief This routine allows to start connection to device through USART interface.\n \\param usartParameters : Indicates customized configuration for USART connection.\n \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub unsafe fn connectUsartBootloader(
        &self,
        usartParameters: usartConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectUsartBootloader
            .as_ref()
            .expect("Expected function, got error."))(usartParameters)
    }
    #[doc = " \\brief This routine allows to send a single byte through the USART interface.\n \\param byte : The data to be written\n \\return 0 if the sending operation correctly achieved, otherwise an error occurred."]
    pub unsafe fn sendByteUart(&self, byte: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        (self
            .sendByteUart
            .as_ref()
            .expect("Expected function, got error."))(byte)
    }
    #[doc = " \\brief This routine allows to get connected DFU devices.\n \\param dfuList : Receive DFU devices list and its default configurations.\n \\param iPID : Indicate the Product ID to be used for DFU interface.\n \\param iVID : Indicate the Vendor ID to be used for DFU interface.\n \\return Number of DFU devices already connected.\n \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub unsafe fn getDfuDeviceList(
        &self,
        dfuList: *mut *mut dfuDeviceInfo,
        iPID: ::std::os::raw::c_int,
        iVID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .getDfuDeviceList
            .as_ref()
            .expect("Expected function, got error."))(dfuList, iPID, iVID)
    }
    #[doc = " \\brief This routine allows to start a simple connection through USB DFU interface.\n \\param usbIndex : Indicates the index of DFU ports already connected.\n \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub unsafe fn connectDfuBootloader(
        &self,
        usbIndex: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .connectDfuBootloader
            .as_ref()
            .expect("Expected function, got error."))(usbIndex)
    }
    #[doc = " \\brief This routine allows to start connection to device through USB DFU interface.\n \\param dfuConnectParameters : Indicates the dfu connection parameters\n \\return 0 if the connection successfully established, otherwise an error occurred.\n \\note  It's recommanded to use this routine to disable readout protection when connecting a MCU based device."]
    pub unsafe fn connectDfuBootloader2(
        &self,
        dfuParameters: dfuConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectDfuBootloader2
            .as_ref()
            .expect("Expected function, got error."))(dfuParameters)
    }
    #[doc = " \\brief This routine allows to start connection to device through SPI interface.\n \\param spiParameters : Indicates customized configuration for  SPI connection\n \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub unsafe fn connectSpiBootloader(
        &self,
        spiParameters: spiConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectSpiBootloader
            .as_ref()
            .expect("Expected function, got error."))(spiParameters)
    }
    #[doc = " \\brief This routine allows to start connection to device through CAN interface.\n \\param canParameters : Indicates customized configuration for  CAN connection\n \\return 0 if the connection successfully established, otherwise an error occurred.\n \\warning To have CAN full support, you must have St-Link firmware version at least v3JxMxB2."]
    pub unsafe fn connectCanBootloader(
        &self,
        canParameters: canConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectCanBootloader
            .as_ref()
            .expect("Expected function, got error."))(canParameters)
    }
    #[doc = " \\brief This routine allows to start connection to device through I2C interface.\n \\param i2cParameters : Indicates customized configuration for  I2C connection\n \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub unsafe fn connectI2cBootloader(
        &self,
        i2cParameters: i2cConnectParameters,
    ) -> ::std::os::raw::c_int {
        (self
            .connectI2cBootloader
            .as_ref()
            .expect("Expected function, got error."))(i2cParameters)
    }
    #[doc = " \\brief This routine allows to choose your custom display.\n \\param c : Fill the struct to customize the display tool.\n \\note This function must be called first of all to ensure the display management."]
    pub unsafe fn setDisplayCallbacks(&self, c: displayCallBacks) {
        (self
            .setDisplayCallbacks
            .as_ref()
            .expect("Expected function, got error."))(c)
    }
    #[doc = " \\brief This routine allows to choose the verbosity level for display.\n \\param level : Indicates the verbosity number 0, 1 or 3."]
    pub unsafe fn setVerbosityLevel(&self, level: ::std::os::raw::c_int) {
        (self
            .setVerbosityLevel
            .as_ref()
            .expect("Expected function, got error."))(level)
    }
    #[doc = " \\brief This routine allows to check connection status [maintained or lost].\n \\return 1 if the device is already connected, otherwise the connection to device is lost."]
    pub unsafe fn checkDeviceConnection(&self) -> ::std::os::raw::c_int {
        (self
            .checkDeviceConnection
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to get general device informations.\n \\return Structure #GeneralInf in which the informations are stored."]
    pub unsafe fn getDeviceGeneralInf(&self) -> *mut generalInf {
        (self
            .getDeviceGeneralInf
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to receive memory data on the used interface with the configration already initialized.\n \\param address   : The address to start reading from.\n \\param data      : Pointer to the data buffer.\n \\param size      : It indicates the size for read data.\n \\return 0 if the reading operation correctly finished, otherwise an error occurred.\n \\warning Unlike ST-LINK interface, the Bootloader interface can access only to some specific memory regions."]
    pub unsafe fn readMemory(
        &self,
        address: ::std::os::raw::c_uint,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .readMemory
            .as_ref()
            .expect("Expected function, got error."))(address, data, size)
    }
    #[doc = " \\brief This routine allows to write memory data on the user interface with the configration already initialized.\n \\param address   : The address to start writing from.\n \\param data      : Pointer to the data buffer.\n \\param size      : It indicates the size for write data.\n \\return 0 if the writing operation correctly finished, otherwise an error occurred.\n \\warning Unlike ST-LINK interface, the Bootloader interface can access only to some specific memory regions."]
    pub unsafe fn writeMemory(
        &self,
        address: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .writeMemory
            .as_ref()
            .expect("Expected function, got error."))(address, data, size)
    }
    #[doc = " \\brief This routine allows to write sector data on the user interface with the configration already initialized.\n \\param address   : The address to start writing from.\n \\param data      : Pointer to the data buffer.\n \\param size      : It indicates the size for write data.\n \\return 0 if the writing operation correctly finished, otherwise an error occurred.\n \\warning Unlike ST-LINK interface, the Bootloader interface can access only to some specific memory regions.\n \\warning Data size should not exceed sector size."]
    pub unsafe fn editSector(
        &self,
        address: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .editSector
            .as_ref()
            .expect("Expected function, got error."))(address, data, size)
    }
    #[doc = " \\brief This routine allows to download data from a file to the memory.\n File formats that are supported : hex, bin, srec, tsv, elf, axf, out, stm32, ext\n \\param filePath  : Indicates the full path of the considered file.\n \\param address   : The address to start downloading from.\n \\param skipErase : In case to win in term time and if we have a blank device, we can skip erasing memory before programming [skipErase=0].\n \\param verify    : To add verification step after downloading.\n \\param binPath   : Path of the binary file.\n \\return 0 if the downloading operation correctly finished, otherwise an error occurred."]
    pub unsafe fn downloadFile(
        &self,
        filePath: *const u16,
        address: ::std::os::raw::c_uint,
        skipErase: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
        binPath: *const u16,
    ) -> ::std::os::raw::c_int {
        (self
            .downloadFile
            .as_ref()
            .expect("Expected function, got error."))(
            filePath, address, skipErase, verify, binPath
        )
    }
    #[doc = " \\brief This routine allows to run the application.\n \\param address : The address to start executing from.\n In most cases, the program will run from the Flash memory starting from 0x08000000.\n \\return 0 if the execution correctly started, otherwise an error occurred."]
    pub unsafe fn execute(&self, address: ::std::os::raw::c_uint) -> ::std::os::raw::c_int {
        (self
            .execute
            .as_ref()
            .expect("Expected function, got error."))(address)
    }
    #[doc = " \\brief This routine allows to erase the whole Flash memory.\n \\return 0 if the operation finished successfully, otherwise an error was occurred.\n \\note Depending on the device, this routine can take a particular period of time."]
    pub unsafe fn massErase(
        &self,
        sFlashMemName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .massErase
            .as_ref()
            .expect("Expected function, got error."))(sFlashMemName)
    }
    #[doc = " \\brief This routine allows to erase specific sectors of the Flash memory.\n \\param sectors   : Indicates the indexs of the specific sectors to be erased.\n \\param sectorNbr : The number of chosen sectors.\n \\return 0 if the operation finished successfully, otherwise an error occurred.\n \\note Each circuit has a specific number of Flash memory sectors."]
    pub unsafe fn sectorErase(
        &self,
        sectors: *mut ::std::os::raw::c_uint,
        sectorNbr: ::std::os::raw::c_uint,
        sFlashMemName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .sectorErase
            .as_ref()
            .expect("Expected function, got error."))(sectors, sectorNbr, sFlashMemName)
    }
    #[doc = " \\brief This routine allows to disable the readout protection.\n If the memory is not protected, a message appears to indicate that the device is not\n under Readout protection and the command has no effects.\n \\return 0 if the disabling correctly accomplished, otherwise an error occurred.\n \\note Depending on the device used, this routine take a specific time."]
    pub unsafe fn readUnprotect(&self) -> ::std::os::raw::c_int {
        (self
            .readUnprotect
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows the TZEN Option Byte regression.\n \\return 0 if the disabling correctly accomplished, otherwise an error occurred.\n \\note Depending on the device used, this routine take a specific time."]
    pub unsafe fn tzenRegression(&self) -> ::std::os::raw::c_int {
        (self
            .tzenRegression
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to know the interface what is in use.\n \\return The target interface type #targetInterfaceType, otherwise -1."]
    pub unsafe fn getTargetInterfaceType(&self) -> ::std::os::raw::c_int {
        (self
            .getTargetInterfaceType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to drop the current read/write operation.\n \\return 0 if there is no call for stop operation, otherwise 1."]
    pub unsafe fn getCancelPointer(&self) -> *mut ::std::os::raw::c_int {
        (self
            .getCancelPointer
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to open and get data from any supported file extension.\n \\param filePath : Indicates the full path of the considered file.\n \\return Pointer to #fileData_C if the file has hex, bin, srec or elf as extension, otherwise a null pointer to indicate that the file type is not supported."]
    pub unsafe fn fileOpen(&self, filePath: *const u16) -> *mut ::std::os::raw::c_void {
        (self
            .fileOpen
            .as_ref()
            .expect("Expected function, got error."))(filePath)
    }
    #[doc = " \\brief This routine allows to clean up the handled file data.\n \\param data"]
    pub unsafe fn freeFileData(&self, data: *mut fileData_C) {
        (self
            .freeFileData
            .as_ref()
            .expect("Expected function, got error."))(data)
    }
    #[doc = " @brief This routine allows to free a specific memory region, typically used after readMemory().\n @param ptr : The input pointer address.\n \\note it's crucial to ensure that the data is no longer in use after you free the memory."]
    pub unsafe fn freeLibraryMemory(&self, ptr: *mut ::std::os::raw::c_void) {
        (self
            .freeLibraryMemory
            .as_ref()
            .expect("Expected function, got error."))(ptr)
    }
    #[doc = " \\brief This routine allows to verfiy if the indicated file data is identical to Flash memory content.\n \\param fileData : Input file name.\n \\param address  : The address to start verifying from, it's considered only if the file has .bin or .binary as extension.\n \\return 0 if the file data matching Flash memory content, otherwise an error occurred or the data is mismatched."]
    pub unsafe fn verify(
        &self,
        fileData: *mut fileData_C,
        address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self.verify.as_ref().expect("Expected function, got error."))(fileData, address)
    }
    #[doc = " \\brief This routine allows to save the data file content to another file.\n \\param fileData  : Input file name.\n \\param sFileName : Output file name.\n \\return 0 if the output file was created successfully, otherwise an error occurred."]
    pub unsafe fn saveFileToFile(
        &self,
        fileData: *mut fileData_C,
        sFileName: *const u16,
    ) -> ::std::os::raw::c_int {
        (self
            .saveFileToFile
            .as_ref()
            .expect("Expected function, got error."))(fileData, sFileName)
    }
    #[doc = " \\brief This routine allows to save Flash memory content to file.\n \\param address   : The address to start saving from.\n \\param size      : Data size to be saved.\n \\param sFileName : Indicates the file name.\n \\return 0 if the data copy was acheived successfully, otherwise an error occurred.\n \\note The file name must finish with an extension \".hex\", \".bin\" or \".srec\""]
    pub unsafe fn saveMemoryToFile(
        &self,
        address: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        sFileName: *const u16,
    ) -> ::std::os::raw::c_int {
        (self
            .saveMemoryToFile
            .as_ref()
            .expect("Expected function, got error."))(address, size, sFileName)
    }
    #[doc = " \\brief This routine allows to clean up and disconnect the current connected target.\n \\note This routine disconnect the target and delete the loaded Flash Loaders."]
    pub unsafe fn disconnect(&self) {
        (self
            .disconnect
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to clear the list of each created interface.\n \\note The list is filled by #getStlinkList, #getDfuDeviceList or #getUsartList."]
    pub unsafe fn deleteInterfaceList(&self) {
        (self
            .deleteInterfaceList
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to enter and make an automatic process for memory management through JTAG/SWD, UART, DFU, SPI, CAN and I²C interfaces.\n \\param filePath      : Indicates the full file path.\n \\param address       : The address to start downloading from.\n \\param skipErase     : If we have a blank device, we can skip erasing memory before programming [skipErase=0].\n \\param verify        : Add verification step after downloading.\n \\param isMassErase   : Erase the whole Flash memory.\n \\param obCommand     : Indicates the option bytes commands to be loaded \"-ob [optionbyte=value] [optionbyte=value]...\"\n \\param run           : Start the application.\n \\warning Connection to target must be established before performing automatic mode."]
    pub unsafe fn automaticMode(
        &self,
        filePath: *const u16,
        address: ::std::os::raw::c_uint,
        skipErase: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
        isMassErase: ::std::os::raw::c_int,
        obCommand: *mut ::std::os::raw::c_char,
        run: ::std::os::raw::c_int,
    ) {
        (self
            .automaticMode
            .as_ref()
            .expect("Expected function, got error."))(
            filePath,
            address,
            skipErase,
            verify,
            isMassErase,
            obCommand,
            run,
        )
    }
    #[doc = " \\brief This routine allows to enter and make an automatic process for memory management with serial numbering through JTAG/SWD, UART, DFU, SPI, CAN and I²C interfaces.\n \\param filePath              : Indicates the full file path.\n \\param address               : The address to start downloading from.\n \\param skipErase             : If we have a blank device, we can skip erasing memory before programming [skipErase=0].\n \\param verify                : Add verification step after downloading.\n \\param isMassErase           : Erase the whole Flash memory.\n \\param obCommand             : Indicates the option bytes commands to be loaded \"-ob [optionbyte=value] [optionbyte=value]...\"\n \\param run                   : Start the application.\n \\param enableSerialNumbering : enables the serial numbering.\n \\param serialAddress         : the address where the inital data and the subsequent increments will be made.\n \\param serialSize            : size for the serial numbering.\n \\param serialInitialData     : intial data used for the serial numbering that will be incremented.\n \\warning Connection to target must be established before performing automatic mode with serial numbering."]
    pub unsafe fn serialNumberingAutomaticMode(
        &self,
        filePath: *const u16,
        address: ::std::os::raw::c_uint,
        skipErase: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
        isMassErase: ::std::os::raw::c_int,
        obCommand: *mut ::std::os::raw::c_char,
        run: ::std::os::raw::c_int,
        enableSerialNumbering: ::std::os::raw::c_int,
        serialAddress: ::std::os::raw::c_int,
        serialSize: ::std::os::raw::c_int,
        serialInitialData: *mut ::std::os::raw::c_char,
    ) {
        (self
            .serialNumberingAutomaticMode
            .as_ref()
            .expect("Expected function, got error."))(
            filePath,
            address,
            skipErase,
            verify,
            isMassErase,
            obCommand,
            run,
            enableSerialNumbering,
            serialAddress,
            serialSize,
            serialInitialData,
        )
    }
    #[doc = " \\brief This routine allows to get Flash storage information.\n \\param deviceStorageStruct   : The data strcurure to load memory sectors information.\n \\return 0 if the operation was acheived successfully, otherwise an error occurred."]
    pub unsafe fn getStorageStructure(
        &self,
        deviceStorageStruct: *mut *mut storageStructure,
    ) -> ::std::os::raw::c_int {
        (self
            .getStorageStructure
            .as_ref()
            .expect("Expected function, got error."))(deviceStorageStruct)
    }
    #[doc = " \\brief This routine allows program the given Option Byte.\n The option bytes are configured by the end user depending on the application requirements.\n \\param command : Indicates the command to execute.\n \\return 0 if the programming Option Byte correctly executed, otherwise an error occurred.\n \\note The command must written as: -ob [optionbyte=value] [optionbyte=value] ...\n \\code\n int ob = sendOptionBytesCmd(\"–ob rdp=0x0 BOR_LEV=0\");\n \\endcode"]
    pub unsafe fn sendOptionBytesCmd(
        &self,
        command: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .sendOptionBytesCmd
            .as_ref()
            .expect("Expected function, got error."))(command)
    }
    #[doc = " \\brief This routine allows to get option bytes values of the connected target.\n \\return Structure #Peripheral_C in which the option bytes descriptions are stored."]
    pub unsafe fn initOptionBytesInterface(&self) -> *mut peripheral_C {
        (self
            .initOptionBytesInterface
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn fastRomInitOptionBytesInterface(&self, deviceId: u16) -> *mut peripheral_C {
        (self
            .fastRomInitOptionBytesInterface
            .as_ref()
            .expect("Expected function, got error."))(deviceId)
    }
    #[doc = " \\brief This routine allows to display the Option bytes.\n \\return 0 if the programming display correctly done, otherwise an error occurred."]
    pub unsafe fn obDisplay(&self) -> ::std::os::raw::c_int {
        (self
            .obDisplay
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to specify the location of Flash Loader.\n \\param path : Indicates the full path of the considered folder."]
    pub unsafe fn setLoadersPath(&self, path: *const ::std::os::raw::c_char) {
        (self
            .setLoadersPath
            .as_ref()
            .expect("Expected function, got error."))(path)
    }
    #[doc = " \\brief This routine allows to specify the path of the external Loaders to be loaded.\n \\param path : Indicates the full path of the folder containing external Loaders.\n \\param externalLoaderInfo : Structure in which the external Loaders informations are stored."]
    pub unsafe fn setExternalLoaderPath(
        &self,
        path: *const ::std::os::raw::c_char,
        externalLoaderInfo: *mut *mut externalLoader,
    ) {
        (self
            .setExternalLoaderPath
            .as_ref()
            .expect("Expected function, got error."))(path, externalLoaderInfo)
    }
    #[doc = " \\brief This routine allows to specify the path of the external Loaders to be loaded via OBL interfaces.\n \\param path : Indicates the full path of the folder containing external Loaders.\n \\param externalLoaderInfo : Structure in which the external Loaders informations are stored."]
    pub unsafe fn setExternalLoaderOBL(
        &self,
        path: *const ::std::os::raw::c_char,
        externalLoaderInfo: *mut *mut externalLoader,
    ) {
        (self
            .setExternalLoaderOBL
            .as_ref()
            .expect("Expected function, got error."))(path, externalLoaderInfo)
    }
    #[doc = " \\brief This routine allows to get available external Loaders in the mentioned path.\n \\param path : Indicates the full path containing ExternalLoader folder.\n \\param externalStorageNfo : Structure in which we get storage information.\n \\return 1 if the External loaders cannot be loaded from the path, otherwise 0.\n \\warning All external Loader files should have the extension \"stldr\"."]
    pub unsafe fn getExternalLoaders(
        &self,
        path: *const ::std::os::raw::c_char,
        externalStorageNfo: *mut *mut externalStorageInfo,
    ) -> ::std::os::raw::c_int {
        (self
            .getExternalLoaders
            .as_ref()
            .expect("Expected function, got error."))(path, externalStorageNfo)
    }
    #[doc = " \\brief This routine allows to unload an external Loaders.\n \\param path : Indicates the full path of the external Loader file ready for unloading."]
    pub unsafe fn removeExternalLoader(&self, path: *const ::std::os::raw::c_char) {
        (self
            .removeExternalLoader
            .as_ref()
            .expect("Expected function, got error."))(path)
    }
    #[doc = " \\brief This routine allows to delete all target Flash Loaders."]
    pub unsafe fn deleteLoaders(&self) {
        (self
            .deleteLoaders
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to read the device unique identifier.\n \\param data : Pointer to the data buffer."]
    pub unsafe fn getUID64(
        &self,
        data: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int {
        (self
            .getUID64
            .as_ref()
            .expect("Expected function, got error."))(data)
    }
    #[doc = " \\brief This routine allows to erase the BLE stack firmware.\n \\return 0 if the operation was acheived successfully, otherwise an error occurred."]
    pub unsafe fn firmwareDelete(&self) -> ::std::os::raw::c_int {
        (self
            .firmwareDelete
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to make upgrade of BLE stack firmware or FUS firmware.\n \\param filePath : Indicates the full path of the firmware to be programmed.\n \\param address : Start address of download.\n \\param firstInstall : 1 if it is the first installation, otherwise 0, to ignore the firmware delete operation.\n \\param startStack : Starts the stack after programming.\n \\param verify : Verify if the download operation is achieved successfully before starting the upgrade.\n \\return true if the operation was acheived successfully, otherwise an error occurred."]
    pub unsafe fn firmwareUpgrade(
        &self,
        filePath: *const u16,
        address: ::std::os::raw::c_uint,
        firstInstall: ::std::os::raw::c_uint,
        startStack: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .firmwareUpgrade
            .as_ref()
            .expect("Expected function, got error."))(
            filePath,
            address,
            firstInstall,
            startStack,
            verify,
        )
    }
    #[doc = " \\brief This routine allows to start the programmed Stack.\n \\return true if the Stack was started successfully, otherwise an error occurred."]
    pub unsafe fn startWirelessStack(&self) -> ::std::os::raw::c_int {
        (self
            .startWirelessStack
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to start the programmed Stack.\n \\param filePath : Indicates the full path of the key file.\n \\note This is the public key generated by STM32TrustedPackageCreator when signing the firmware using -sign command.\n \\return true if the update was performed successfully, otherwise an error occurred."]
    pub unsafe fn updateAuthKey(&self, filePath: *const u16) -> ::std::os::raw::c_int {
        (self
            .updateAuthKey
            .as_ref()
            .expect("Expected function, got error."))(filePath)
    }
    #[doc = " \\brief This routine allows to lock the authentication key and once locked, it is no longer possible to change it.\n \\return 0 if the lock step was performed successfully, otherwise an error occurred."]
    pub unsafe fn authKeyLock(&self) -> ::std::os::raw::c_int {
        (self
            .authKeyLock
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to write a customized user key.\n \\param filePath : Indicates the full path of the key file.\n \\param keyType  : String indicating the key type to be used \"Simple\", \"Master\", \"Encrypted\".\n \\return 0 if the write was performed successfully, otherwise an error occurred."]
    pub unsafe fn writeUserKey(
        &self,
        filePath: *const u16,
        keyType: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int {
        (self
            .writeUserKey
            .as_ref()
            .expect("Expected function, got error."))(filePath, keyType)
    }
    #[doc = " \\brief This routine allows to activate the AntiRollBack.\n \\return true if the activation was done successfully, otherwise an error occurred."]
    pub unsafe fn antiRollBack(&self) -> ::std::os::raw::c_int {
        (self
            .antiRollBack
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to start and establish a communication with the FUS operator.\n \\return true if the FUS operator was started successfully, otherwise an error occurred.\n \\note Availbale only for ST-LINK interfaces."]
    pub unsafe fn startFus(&self) -> ::std::os::raw::c_int {
        (self
            .startFus
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine allows to set default option Bytes."]
    pub unsafe fn unlockchip(&self) -> ::std::os::raw::c_int {
        (self
            .unlockchip
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " \\brief This routine aims to launch the Secure Secret Provisioning.\n \\param sspFile  : Indicates the full path of the ssp file [Use STM32TrustedPackageCreator to generate a ssp image].\n \\param licenseFile  : Indicates the full path of the license file. If you are trying to start the SSP without HSM, the hsmSlotId should be 0.\n \\param tfaFile  : Indicates the full path of the tfa-ssp file.\n \\param hsmSlotId  : Indicates the HSM slot ID.\n \\return 0 if the SSP was finished successfully, otherwise an error occurred.\n \\note If you are trying to start the SSP with HSM, the licenseFile parametre should be empty."]
    pub unsafe fn programSsp(
        &self,
        sspFile: *const u16,
        licenseFile: *const u16,
        tfaFile: *const u16,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .programSsp
            .as_ref()
            .expect("Expected function, got error."))(
            sspFile, licenseFile, tfaFile, hsmSlotId
        )
    }
    #[doc = " @brief getHsmFirmwareID: this routine aims to get the HSM Firmware Identifier.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @return string that contains the HSM Firmware Identifier."]
    pub unsafe fn getHsmFirmwareID(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .getHsmFirmwareID
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId)
    }
    #[doc = " @brief getHsmCounter: this routine aims to get the current HSM counter.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @return Counter value"]
    pub unsafe fn getHsmCounter(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong {
        (self
            .getHsmCounter
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId)
    }
    #[doc = " @brief getHsmState: this routine aims to get the HSM State.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @return string with possible values: ST_STATE , OEM_STATE, OPERATIONAL_STATE , UNKNOWN_STATE"]
    pub unsafe fn getHsmState(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .getHsmState
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId)
    }
    #[doc = " @brief getHsmVersion: this routine aims to get the HSM version.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @return string with possible values: 1 , 2"]
    pub unsafe fn getHsmVersion(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .getHsmVersion
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId)
    }
    #[doc = " @brief getHsmType: this routine aims to get the HSM type.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @return string with possible values: SFI. SMU. SSP..."]
    pub unsafe fn getHsmType(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char {
        (self
            .getHsmType
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId)
    }
    #[doc = " @brief getHsmLicense: this routine aims to get and save the HSM license into a binary file.\n @param hsmSlotId: The slot index of the plugud-in HSM\n @param outLicensePath: path of the output binary file.\n @return 0 if the operation was finished successfully, otherwise an error occurred.\n \\note Connection to target must be established before performing this routine."]
    pub unsafe fn getHsmLicense(
        &self,
        hsmSlotId: ::std::os::raw::c_int,
        outLicensePath: *const u16,
    ) -> ::std::os::raw::c_int {
        (self
            .getHsmLicense
            .as_ref()
            .expect("Expected function, got error."))(hsmSlotId, outLicensePath)
    }
    #[doc = " \\brief Write a core register.\n \\param reg : The register to write.\n \\param data     : The data to write.\n \\return 0 if the writing operation correctly finished, otherwise an error occurred."]
    pub unsafe fn writeCortexRegistres(
        &self,
        reg: ::std::os::raw::c_uint,
        data: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .writeCortexRegistres
            .as_ref()
            .expect("Expected function, got error."))(reg, data)
    }
    #[doc = " \\brief Read a core register.\n \\param reg : The register to read.\n \\param data     : The data read.\n \\return 0 if the reading operation correctly finished, otherwise an error occurred."]
    pub unsafe fn readCortexReg(
        &self,
        reg: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .readCortexReg
            .as_ref()
            .expect("Expected function, got error."))(reg, data)
    }
}
